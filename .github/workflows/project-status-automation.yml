name: Project Status Automation

on:
  issues:
    types: [labeled, unlabeled, assigned, unassigned]
  pull_request:
    types: [opened, closed, reopened]

jobs:
  update-project-status:
    runs-on: ubuntu-latest
    if: github.event.issue || github.event.pull_request
    
    steps:
      - name: Update Project Status Based on Labels and Assignment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const issue = context.payload.issue;
            const pullRequest = context.payload.pull_request;
            const action = context.payload.action;
            
            // Project configuration
            const PROJECT_NUMBER = 5;
            const OWNER = context.repo.owner;
            const REPO = context.repo.repo;
            
            // Determine if this is a PR or issue event
            let targetIssues = [];
            
            if (issue) {
              // Direct issue event
              console.log(`Processing ${action} action for issue #${issue.number}: ${issue.title}`);
              targetIssues = [issue];
            } else if (pullRequest) {
              // Pull request event - find linked issues
              console.log(`Processing ${action} action for PR #${pullRequest.number}: ${pullRequest.title}`);
              
              // Extract issue numbers from PR body and title using common patterns
              const prText = `${pullRequest.title} ${pullRequest.body || ''}`;
              const issuePatterns = [
                /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s*:?\s*#(\d+)/gi,
                /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+(?:https?:\/\/github\.com\/[^\/]+\/[^\/]+\/issues\/)?(\d+)/gi,
                /#(\d+)/g
              ];
              
              const linkedIssueNumbers = new Set();
              
              for (const pattern of issuePatterns) {
                let match;
                while ((match = pattern.exec(prText)) !== null) {
                  linkedIssueNumbers.add(parseInt(match[1]));
                }
              }
              
              console.log(`Found linked issues: ${Array.from(linkedIssueNumbers).join(', ')}`);
              
              // Fetch each linked issue
              for (const issueNumber of linkedIssueNumbers) {
                try {
                  const { data: linkedIssue } = await github.rest.issues.get({
                    owner: OWNER,
                    repo: REPO,
                    issue_number: issueNumber
                  });
                  targetIssues.push(linkedIssue);
                } catch (error) {
                  console.log(`Could not fetch issue #${issueNumber}: ${error.message}`);
                }
              }
            }
            
            if (targetIssues.length === 0) {
              console.log('No target issues found');
              return;
            }
            
            // Get project ID and fields
            const projectQuery = `
              query($owner: String!, $number: Int!) {
                user(login: $owner) {
                  projectV2(number: $number) {
                    id
                    fields(first: 20) {
                      nodes {
                        ... on ProjectV2Field {
                          id
                          name
                          dataType
                        }
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          dataType
                          options {
                            id
                            name
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            const projectResult = await github.graphql(projectQuery, {
              owner: OWNER,
              number: PROJECT_NUMBER
            });
            
            const project = projectResult.user.projectV2;
            if (!project) {
              console.log('Project not found');
              return;
            }
            
            // Find status field
            const statusField = project.fields.nodes.find(field => field.name === 'Status');
            
            if (!statusField) {
              console.log('Status field not found in project');
              return;
            }
            
            console.log('Found status field:', statusField.id);
            
            // Status mapping: label -> project status ID (direct mapping)
            const statusMap = {
              'Backlog': 'f75ad846',        // Backlog
              'Ã€ Faire': '08afe404',        // Ã€ Faire
              'En Cours': '47fc9ee4',       // En Cours
              'Review': '4cc61d42',         // Review
              'Testing': 'd2573237',        // Testing
              'Done': '98236657',           // Done
              'Released': '111ec098'        // Released
            };
            
            // Helper function to update project status
            async function updateProjectStatus(statusOptionId, itemId) {
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(
                    input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }
                  ) {
                    projectV2Item { id }
                  }
                }
              `;
              
              await github.graphql(mutation, {
                projectId: project.id,
                itemId: itemId,
                fieldId: statusField.id,
                optionId: statusOptionId
              });
            }
            
            // Helper function to add/remove labels
            async function updateIssueLabel(labelName, shouldAdd, issueNumber) {
              // Get current labels for this specific issue
              const { data: currentIssue } = await github.rest.issues.get({
                owner: OWNER,
                repo: REPO,
                issue_number: issueNumber
              });
              const currentLabels = currentIssue.labels.map(l => l.name);
              
              if (shouldAdd) {
                // Add label if not already present
                if (!currentLabels.includes(labelName)) {
                  await github.rest.issues.addLabels({
                    owner: OWNER,
                    repo: REPO,
                    issue_number: issueNumber,
                    labels: [labelName]
                  });
                  console.log(`âœ… Added label: ${labelName} to issue #${issueNumber}`);
                }
              } else {
                // Remove label if present
                if (currentLabels.includes(labelName)) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: OWNER,
                      repo: REPO,
                      issue_number: issueNumber,
                      name: labelName
                    });
                    console.log(`ðŸ—‘ï¸ Removed label: ${labelName} from issue #${issueNumber}`);
                  } catch (error) {
                    if (error.status !== 404) {
                      console.error(`Error removing label ${labelName} from issue #${issueNumber}:`, error);
                    }
                  }
                }
              }
            }
            
            // Process each target issue
            for (const targetIssue of targetIssues) {
              console.log(`\n--- Processing issue #${targetIssue.number}: ${targetIssue.title} ---`);
              
              // Get project item for this issue
              const itemQuery = `
                query($owner: String!, $repo: String!, $issueNumber: Int!) {
                  repository(owner: $owner, name: $repo) {
                    issue(number: $issueNumber) {
                      projectItems(first: 10) {
                        nodes {
                          id
                          project {
                            id
                          }
                        }
                      }
                      labels(first: 20) {
                        nodes {
                          name
                        }
                      }
                      assignees(first: 10) {
                        nodes {
                          login
                        }
                      }
                    }
                  }
                }
              `;
              
              const itemResult = await github.graphql(itemQuery, {
                owner: OWNER,
                repo: REPO,
                issueNumber: targetIssue.number
              });
              
              const projectItem = itemResult.repository.issue.projectItems.nodes.find(
                item => item.project.id === project.id
              );
              
              if (!projectItem) {
                console.log(`Issue #${targetIssue.number} not found in project`);
                continue;
              }
              
              const labels = itemResult.repository.issue.labels.nodes.map(label => label.name);
              const assignees = itemResult.repository.issue.assignees.nodes.map(assignee => assignee.login);
              
              console.log('Current labels:', labels);
              console.log('Current assignees:', assignees);
              
              try {
                // Determine the appropriate status based on event type, labels and assignment
                let targetStatus = null;
                let targetStatusName = null;
                let shouldAddLabel = null;
                let shouldRemoveLabels = [];
                
                // Special logic for PR events
                if (pullRequest && action === 'opened') {
                  // When PR is opened, set linked issues to Review
                  targetStatus = statusMap['Review'];
                  targetStatusName = 'Review';
                  shouldAddLabel = 'Review';
                  // Remove conflicting status labels
                  shouldRemoveLabels = ['Backlog', 'Ã€ Faire', 'En Cours'];
                  console.log('PR opened - setting linked issues to Review');
                } else if (pullRequest && action === 'closed' && pullRequest.merged) {
                  // When PR is merged, set to Testing
                  targetStatus = statusMap['Testing'];
                  targetStatusName = 'Testing';
                  shouldAddLabel = 'Testing';
                  shouldRemoveLabels = ['Review'];
                  console.log('PR merged - setting linked issues to Testing');
                } else if (pullRequest && action === 'closed' && !pullRequest.merged) {
                  // When PR is closed without merging, revert to En Cours
                  targetStatus = statusMap['En Cours'];
                  targetStatusName = 'En Cours';
                  shouldAddLabel = 'En Cours';
                  shouldRemoveLabels = ['Review'];
                  console.log('PR closed without merge - reverting linked issues to En Cours');
                } else {
                  // Standard issue logic
                  // Priority logic:
                  // 1. If assigned and not already in-development -> set to in-development
                  // 2. Check for explicit status labels in priority order
                  
                  if (assignees.length > 0 && !labels.includes('En Cours')) {
                    // Issue is assigned but not marked as En Cours
                    targetStatus = statusMap['En Cours'];
                    targetStatusName = 'En Cours';
                    shouldAddLabel = 'En Cours';
                    // Remove conflicting status labels
                    shouldRemoveLabels = ['Backlog', 'Ã€ Faire'];
                  } else {
                    // Check for status labels in priority order
                    const statusLabels = [
                      'Released',
                      'Done', 
                      'Testing',
                      'Review',
                      'En Cours',
                      'Ã€ Faire',
                      'Backlog'
                    ];
                    
                    for (const statusLabel of statusLabels) {
                      if (labels.includes(statusLabel)) {
                        targetStatus = statusMap[statusLabel];
                        targetStatusName = statusField.options.find(opt => opt.id === targetStatus)?.name;
                        break;
                      }
                    }
                  }
                }
                
                // Apply changes if we determined a target status
                if (targetStatus && targetStatusName) {
                  // Update project status
                  await updateProjectStatus(targetStatus, projectItem.id);
                  console.log(`âœ… Updated project status to: ${targetStatusName}`);
                  
                  // Add label if needed
                  if (shouldAddLabel) {
                    await updateIssueLabel(shouldAddLabel, true, targetIssue.number);
                  }
                  
                  // Remove conflicting labels
                  for (const labelToRemove of shouldRemoveLabels) {
                    await updateIssueLabel(labelToRemove, false, targetIssue.number);
                  }
                } else {
                  console.log('No status change needed');
                }
                
              } catch (error) {
                console.error(`Error processing issue #${targetIssue.number}:`, error);
              }
            }
            
            console.log('\nProject status automation completed successfully');